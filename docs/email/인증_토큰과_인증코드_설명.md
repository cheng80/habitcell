# 인증 토큰과 인증 코드 설명

비밀번호 변경 프로세스에서 사용되는 인증 토큰과 인증 코드의 차이와 생성 방법을 설명합니다.

**작성일**: 2026-01-23  
**작성자**: 김택권

---

## 📋 목차

1. [개요](#1-개요)
2. [현재 시스템에서 사용하는 방식](#2-현재-시스템에서-사용하는-방식)
3. [인증 토큰 (Auth Token)](#3-인증-토큰-auth-token)
4. [인증 코드 (Auth Code)](#4-인증-코드-auth-code)
5. [차이점 비교](#5-차이점-비교)
6. [생성 방법](#6-생성-방법)
7. [사용 흐름](#7-사용-흐름)

---

## 1. 개요

비밀번호 변경 프로세스에서는 두 가지 인증 수단을 사용합니다:

- **인증 토큰 (Auth Token)**: 서버에서 생성하여 클라이언트에 전달하는 고유 식별자 (백그라운드에서 사용)
- **인증 코드 (Auth Code)**: 이메일로 발송되어 사용자가 입력하는 6자리 숫자 (사용자가 직접 입력)

이 두 가지를 조합하여 보안을 강화합니다.

---

## 2. 현재 시스템에서 사용하는 방식

### 하이브리드 방식 (토큰 + 코드)

현재 시스템은 **하이브리드 방식**을 사용합니다:

1. **인증 토큰 (UUID)**: 백그라운드에서 사용
   - 서버에서 생성하여 클라이언트에만 전달
   - 사용자에게는 보이지 않음
   - 인증 세션을 식별하는 데 사용

2. **인증 코드 (6자리 숫자)**: 사용자가 직접 입력
   - 이메일로 발송되어 사용자가 받음
   - 사용자가 화면에 직접 입력
   - 본인 확인을 위해 사용

### 실제 동작 방식

```
1. 비밀번호 변경 요청
   → 서버: auth_token (UUID) 생성 + auth_code (6자리) 생성
   → 이메일: auth_code만 발송 (예: "인증 코드: 123456")
   → 클라이언트: auth_token만 받음 (사용자에게는 보이지 않음)

2. 인증 코드 검증
   → 사용자: 이메일에서 받은 6자리 코드 입력 (예: "123456")
   → 클라이언트: auth_token + auth_code 함께 전송
   → 서버: auth_token으로 레코드 찾고, auth_code 비교

3. 비밀번호 변경
   → 클라이언트: auth_token만 전송 (이미 인증 완료됨)
   → 서버: auth_token으로 인증 완료 여부 확인 후 비밀번호 변경
```

### 사용자 관점

**사용자가 보는 것:**
- ✅ **인증 코드만**: 이메일로 받은 6자리 숫자만 입력
- ❌ **인증 토큰은 보이지 않음**: 백그라운드에서 자동 처리

**실제로는:**
- 인증 토큰과 인증 코드 **둘 다** 사용하지만
- 사용자는 **인증 코드만** 입력하면 됨
- 인증 토큰은 앱이 자동으로 관리

---

## 3. 인증 토큰 (Auth Token)

### 정의
- **형식**: UUID v4 (Universally Unique Identifier)
- **길이**: 36자 (하이픈 포함) 또는 32자 (하이픈 제외)
- **예시**: `550e8400-e29b-41d4-a716-446655440000`

### 특징
- **고유성**: 전 세계적으로 고유한 값 보장
- **예측 불가능**: 랜덤하게 생성되어 추측 불가능
- **보안성**: 직접 노출되지 않음 (클라이언트에만 전달)
- **용도**: 서버에서 인증 세션을 식별하는 데 사용

### 생성 방법
```python
import uuid

# UUID v4 생성
auth_token = str(uuid.uuid4())
# 결과 예시: "550e8400-e29b-41d4-a716-446655440000"
```

### 사용 위치
- **백엔드**: `fastapi/app/api/customer.py` (883번째 줄)
- **프론트엔드**: `lib/view/auth/password_change_screen.dart` (42번째 줄, `_authToken` 변수)

### 데이터베이스 저장
- **테이블**: `password_reset_auth`
- **컬럼**: `auth_token` (VARCHAR(255))
- **인덱스**: `idx_auth_token` (빠른 조회를 위해)

---

## 4. 인증 코드 (Auth Code)

### 정의
- **형식**: 6자리 숫자
- **범위**: 100000 ~ 999999
- **예시**: `123456`, `789012`

### 특징
- **사용자 친화적**: 짧고 기억하기 쉬움
- **입력 용이**: 숫자만 입력하면 됨
- **이메일 발송**: 사용자 이메일로 직접 전달
- **용도**: 사용자가 본인 확인을 위해 입력

### 생성 방법
```python
import random

# 6자리 숫자 생성 (100000 ~ 999999)
auth_code = f"{random.randint(100000, 999999)}"
# 결과 예시: "123456"
```

### 사용 위치
- **백엔드**: `fastapi/app/api/customer.py` (884번째 줄)
- **프론트엔드**: `lib/view/auth/password_change_screen.dart` (41번째 줄, `_authCodeController`)

### 데이터베이스 저장
- **테이블**: `password_reset_auth`
- **컬럼**: `auth_code` (VARCHAR(6))
- **선택사항**: NULL 가능 (인증 링크 방식 사용 시)

---

## 5. 차이점 비교

| 항목 | 인증 토큰 (Auth Token) | 인증 코드 (Auth Code) |
|------|----------------------|---------------------|
| **형식** | UUID v4 (36자) | 6자리 숫자 |
| **생성 방법** | `uuid.uuid4()` | `random.randint(100000, 999999)` |
| **용도** | 서버 세션 식별 | 사용자 입력 검증 |
| **전달 방법** | API 응답 (JSON) | 이메일 발송 |
| **사용자 노출** | ❌ 숨김 (클라이언트에만) | ✅ 이메일로 전달 |
| **입력 필요** | ❌ 자동 처리 | ✅ 사용자가 직접 입력 |
| **보안 수준** | 높음 (예측 불가능) | 중간 (6자리 숫자) |
| **만료 시간** | 10분 | 10분 (토큰과 동일) |
| **일회용** | ✅ 사용 후 무효화 | ✅ 사용 후 무효화 |

---

## 6. 생성 방법

### 5.1 백엔드에서 생성

**파일**: `fastapi/app/api/customer.py`

```python
import uuid
import random
from datetime import datetime, timedelta

# 4. 인증 토큰 및 코드 생성
auth_token = str(uuid.uuid4())  # UUID v4 생성
auth_code = f"{random.randint(100000, 999999)}"  # 6자리 숫자
expires_at = datetime.now() + timedelta(minutes=10)  # 10분 후 만료

# 5. 데이터베이스에 저장
curs.execute("""
    INSERT INTO password_reset_auth 
    (customer_seq, auth_token, auth_code, expires_at, is_verified, created_at) 
    VALUES (%s, %s, %s, %s, FALSE, NOW())
""", (customer_seq, auth_token, auth_code, expires_at))
```

### 5.2 UUID v4 상세 설명

**UUID (Universally Unique Identifier)**:
- **버전**: v4 (랜덤 UUID)
- **형식**: `xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx`
  - `x`: 16진수 (0-9, a-f)
  - `4`: UUID 버전 (v4)
  - `y`: 8, 9, a, b 중 하나
- **총 길이**: 36자 (하이픈 포함) 또는 32자 (하이픈 제외)
- **고유성**: 전 세계적으로 고유한 값 보장
- **예측 불가능**: 암호학적으로 안전한 난수 생성기 사용

**예시**:
```
550e8400-e29b-41d4-a716-446655440000
f47ac10b-58cc-4372-a567-0e02b2c3d479
6ba7b810-9dad-11d1-80b4-00c04fd430c8
```

### 5.3 6자리 인증 코드 상세 설명

**생성 범위**: 100000 ~ 999999
- **최소값**: 100000 (6자리 보장)
- **최대값**: 999999 (6자리 보장)
- **총 가능한 조합**: 900,000개

**예시**:
```
123456
789012
456789
```

---

## 7. 사용 흐름

### 6.1 비밀번호 변경 요청

```
1. 사용자가 "비밀번호 변경" 요청
   ↓
2. 백엔드에서 인증 토큰 생성 (UUID)
   auth_token = "550e8400-e29b-41d4-a716-446655440000"
   ↓
3. 백엔드에서 인증 코드 생성 (6자리 숫자)
   auth_code = "123456"
   ↓
4. 데이터베이스에 저장
   - auth_token: "550e8400-e29b-41d4-a716-446655440000"
   - auth_code: "123456"
   - expires_at: 현재 시간 + 10분
   - is_verified: FALSE
   ↓
5. 이메일로 인증 코드 발송
   → 사용자 이메일: "인증 코드: 123456"
   ↓
6. API 응답으로 인증 토큰 반환 (클라이언트에만)
   {
     "result": "OK",
     "auth_token": "550e8400-e29b-41d4-a716-446655440000",
     "expires_at": "2026-01-23T01:00:00"
   }
```

### 6.2 인증 코드 검증

```
1. 사용자가 이메일에서 받은 인증 코드 입력
   사용자 입력: "123456"
   ↓
2. 클라이언트에서 API 호출
   POST /api/customer/verify-password-change-code
   {
     "customer_seq": 8,
     "auth_token": "550e8400-e29b-41d4-a716-446655440000",  // 클라이언트에 저장된 토큰
     "auth_code": "123456"  // 사용자가 입력한 코드
   }
   ↓
3. 백엔드에서 검증
   - auth_token으로 DB에서 레코드 조회
   - 저장된 auth_code와 입력된 auth_code 비교
   - 만료 시간 확인
   - is_verified = TRUE로 업데이트
   ↓
4. 인증 성공 시 비밀번호 변경 화면으로 이동
```

### 6.3 비밀번호 변경

```
1. 사용자가 새 비밀번호 입력
   ↓
2. 클라이언트에서 API 호출
   PUT /api/customer/change-password
   {
     "customer_seq": 8,
     "new_password": "새비밀번호",
     "auth_token": "550e8400-e29b-41d4-a716-446655440000"  // 인증 완료된 토큰
   }
   ↓
3. 백엔드에서 검증
   - auth_token으로 DB에서 레코드 조회
   - is_verified = TRUE 확인
   - 만료 시간 확인
   - 비밀번호 변경
   - 인증 레코드 삭제 또는 무효화
```

---

## 8. 보안 고려사항

### 7.1 인증 토큰의 보안성
- ✅ **예측 불가능**: UUID v4는 암호학적으로 안전한 난수 사용
- ✅ **고유성**: 전 세계적으로 고유한 값 보장
- ✅ **노출 최소화**: 클라이언트에만 전달, 이메일로 발송되지 않음

### 7.2 인증 코드의 보안성
- ⚠️ **예측 가능**: 6자리 숫자 (900,000개 조합)
- ✅ **만료 시간**: 10분 후 자동 만료
- ✅ **일회용**: 사용 후 즉시 무효화
- ✅ **시도 제한**: 5회 실패 시 토큰 무효화 (향후 구현)

### 7.3 두 가지를 함께 사용하는 이유
1. **이중 인증**: 토큰만으로는 부족, 코드도 필요
2. **사용자 확인**: 이메일을 받은 사용자만 코드를 알 수 있음
3. **보안 강화**: 토큰 유출 시에도 코드가 없으면 사용 불가

---

## 9. 코드 위치

### 백엔드
- **파일**: `fastapi/app/api/customer.py`
- **함수**: `request_password_change()` (837번째 줄)
- **생성 코드**:
  ```python
  auth_token = str(uuid.uuid4())  # 883번째 줄
  auth_code = f"{random.randint(100000, 999999)}"  # 884번째 줄
  ```

### 프론트엔드
- **파일**: `lib/view/auth/password_change_screen.dart`
- **변수**:
  - `_authToken`: 인증 토큰 저장 (42번째 줄)
  - `_authCodeController`: 인증 코드 입력 필드 (41번째 줄)

### 데이터베이스
- **테이블**: `password_reset_auth`
- **컬럼**:
  - `auth_token` (VARCHAR(255)): 인증 토큰 저장
  - `auth_code` (VARCHAR(6)): 인증 코드 저장

---

## 10. 요약

### 인증 토큰 (UUID)
- **생성**: `uuid.uuid4()` → 36자 UUID 문자열
- **용도**: 서버에서 인증 세션 식별
- **전달**: API 응답 (클라이언트에만)
- **보안**: 높음 (예측 불가능)

### 인증 코드 (6자리 숫자)
- **생성**: `random.randint(100000, 999999)` → 6자리 숫자
- **용도**: 사용자가 입력하여 본인 확인
- **전달**: 이메일 발송
- **보안**: 중간 (6자리 숫자, 만료 시간으로 보완)

### 함께 사용하는 이유
- **이중 인증**: 토큰 + 코드로 보안 강화
- **사용자 확인**: 이메일 수신자만 코드를 알 수 있음
- **보안 강화**: 토큰 유출 시에도 코드가 없으면 사용 불가

---

**마지막 업데이트**: 2026-01-23
